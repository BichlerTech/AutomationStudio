/*
 * generated by Xtext
 */
package com.bichler.iec.generator

import com.bichler.iec.iec.ArrayInitialization
import com.bichler.iec.iec.ArrayVariable
import com.bichler.iec.iec.AssignStatement
import com.bichler.iec.iec.BinaryExpression
import com.bichler.iec.iec.BitString
import com.bichler.iec.iec.BitStringType
import com.bichler.iec.iec.Boolean
import com.bichler.iec.iec.CaseElement
import com.bichler.iec.iec.CaseListElement
import com.bichler.iec.iec.CaseStatement
import com.bichler.iec.iec.CharacterString
import com.bichler.iec.iec.ConfigurationDeclaration
import com.bichler.iec.iec.DateAndTimeLiteral
import com.bichler.iec.iec.DateLiteral
import com.bichler.iec.iec.DateType
import com.bichler.iec.iec.DeclSpecification
import com.bichler.iec.iec.DerivedType
import com.bichler.iec.iec.DirectVariable
import com.bichler.iec.iec.DurationLiteral
import com.bichler.iec.iec.EdgeDeclSpecification
import com.bichler.iec.iec.ElementaryType
import com.bichler.iec.iec.ElseIf
import com.bichler.iec.iec.Expression
import com.bichler.iec.iec.FunctionBlockDeclaration
import com.bichler.iec.iec.FunctionBlockVarDeclarations
import com.bichler.iec.iec.FunctionDeclaration
import com.bichler.iec.iec.GenericType
import com.bichler.iec.iec.IfStatement
import com.bichler.iec.iec.InitialElement
import com.bichler.iec.iec.InputDeclarations
import com.bichler.iec.iec.InputOutputDeclarations
import com.bichler.iec.iec.Instruction
import com.bichler.iec.iec.InstructionList
import com.bichler.iec.iec.IntegerLiteral
import com.bichler.iec.iec.IntegerType
import com.bichler.iec.iec.IoVarDeclarations
import com.bichler.iec.iec.MultiElementVariable
import com.bichler.iec.iec.NamedVariableAccess
import com.bichler.iec.iec.NonGenericType
import com.bichler.iec.iec.NumericType
import com.bichler.iec.iec.OutputDeclarations
import com.bichler.iec.iec.PlainIntegerType
import com.bichler.iec.iec.ProgramConfiguration
import com.bichler.iec.iec.ProgramDeclaration
import com.bichler.iec.iec.RealLiteral
import com.bichler.iec.iec.RealType
import com.bichler.iec.iec.SelectionStatement
import com.bichler.iec.iec.SignedIntegerType
import com.bichler.iec.iec.Statement
import com.bichler.iec.iec.StatementList
import com.bichler.iec.iec.StringType
import com.bichler.iec.iec.StructureInitialization
import com.bichler.iec.iec.StructuredVariable
import com.bichler.iec.iec.SymbolicVariableAccess
import com.bichler.iec.iec.TaskConfiguration
import com.bichler.iec.iec.TimeOfDayLiteral
import com.bichler.iec.iec.UnaryExpression
import com.bichler.iec.iec.UnsignedIntegerType
import com.bichler.iec.iec.Var1List
import com.bichler.iec.iec.VarDeclSpecification
import com.bichler.iec.iec.VarDeclarations
import com.bichler.iec.iec.VariableAccess
import java.util.GregorianCalendar
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.internal.xtend.expression.ast.Identifier
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class IecGenerator implements IGenerator {

	public var ProgramDeclaration prog;
	// private var String datatypes;
	// public var int actMemIndex = 0;
	public var int actIncrement = 0;
	public var String actReplaceMent = ""; 
	private final int IEC_BOOL_SIZE = 1;

	private final int IEC_BYTE_SIZE = 1;
	private final int IEC_WORD_SIZE = 2;
	private final int IEC_DWORD_SIZE = 4;
	private final int IEC_LWORD_SIZE = 8;
	private final int IEC_SINT_SIZE = 1;
	private final int IEC_INT_SIZE = 2;
	private final int IEC_DINT_SIZE = 4;
	private final int IEC_LINT_SIZE = 8;
	private final int IEC_USINT_SIZE = 1;
	private final int IEC_UINT_SIZE = 2;
	private final int IEC_UDINT_SIZE = 4;
	private final int IEC_ULINT_SIZE = 8;
	private final int IEC_REAL_SIZE = 4;
	private final int IEC_LREAL_SIZE = 8;

	private final int IEC_CHAR_SIZE = 1;
	private final int IEC_WCHAR_SIZE = 2;

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		// prog = null;
		/**
		 * 	generate header file for functions
		 */
		var String s = "#ifndef IEC_HEADERS_H_
#define IEC_HEADERS_H_ 1

#include <time.h>
#include <stdlib.h>
#include <stdio.h>

#include \"types.h\"

// structure prototypes for function In-Out variables
"
		var IecFunctionGenerator fgen = new IecFunctionGenerator();
		for (e : resource.allContents.toIterable.filter(FunctionDeclaration)) {
			s += fgen.compileFunctionStructPrototype(e); // e.compileFunctionStructPrototype
		}
		s += "
// structure prototypes for function_block In-Out variables
"
		var IecFunctionBlockGenerator fbgen = new IecFunctionBlockGenerator();
		for (e : resource.allContents.toIterable.filter(FunctionBlockDeclaration)) {
			s += fbgen.compileFunctionBlockStructPrototype(e);
		}
		s += "
// structure prototypes for program In-Out variables
"
		var IecProgramGenerator pgen = new IecProgramGenerator();
		for (e : resource.allContents.toIterable.filter(ProgramDeclaration)) {
			s += pgen.compileProgramStructPrototype(e);
		}

		s += "
// structure prototypes for configuration variables
"
		var IecConfigurationGenerator cgen = new IecConfigurationGenerator();
		for (e : resource.allContents.toIterable.filter(ConfigurationDeclaration)) {
			s += cgen.compileConfigurationStructPrototype(e);
		}

		s += "
// memory allocation for all variables
"
		// var IecProgramGenerator pgen = new IecProgramGenerator();
		for (e : resource.allContents.toIterable.filter(ProgramConfiguration)) {
			s += pgen.compileProgramMemory(e);
		}

		s += "

/**
*	prototypes for iec functions
*/
"
		for (e : resource.allContents.toIterable.filter(FunctionDeclaration)) {
			s += fgen.compileFunctionDeclarationPrototypes(e);
		}
		s += "
/**
*	prototypes for iec function_blocks
*/
"
		for (e : resource.allContents.toIterable.filter(FunctionBlockDeclaration)) {
			s += fbgen.compileFunctionBlockDeclarationPrototypes(e);
		}
		s += "
/**
*	prototypes for iec programs
*/
"
		for (e : resource.allContents.toIterable.filter(ProgramDeclaration)) {
			s += pgen.compileProgramDeclarationPrototypes(e);
		}
		s += "
#endif // IEC_HEADERS_H_"
		fsa.generateFile(resource.URI.lastSegment.replace('.iec', '.h'), s)

		s = "#ifndef IEC_STRUCTURES_H_
#define IEC_STRUCTURES_H_ 1

#include <time.h>
#include <stdlib.h>
#include <stdio.h>

#include \"types.h\"
#include \"headers.h\"

"

		s += "
// structure for function In-Out variables
"
		for (e : resource.allContents.toIterable.filter(FunctionDeclaration)) {
			s += fgen.compileFunctionDeclarationStructs(e);
		}
		s += "
// structure for FUNCTION_BLOCK In-Out variables
"
		for (e : resource.allContents.toIterable.filter(FunctionBlockDeclaration)) {
			s += fbgen.compileFunctionBlockDeclarationStructs(e);
		}
		s += "
// structure for program In-Out variables
"
		for (e : resource.allContents.toIterable.filter(ProgramDeclaration)) {
			s += pgen.compileProgramDeclarationStructs(e);
		}
		s += "
// structure for configuration variables
"
		for (e : resource.allContents.toIterable.filter(ConfigurationDeclaration)) {
			s += cgen.compileConfigurationDeclarationStructs(e);
		}
		s += "
#endif // IEC_STRUCTURES_H_"
		fsa.generateFile(resource.URI.lastSegment.replace('.iec', '') + '_structs.h', s)

		s = "#include <time.h>
#include <stdlib.h>
#include <stdio.h>

#include \"types.h\"
#include \"headers.h\"
#include \"structs.h\"
"
		s += "
// memory allocation for all variables
int initMemory()
{
"
		// var IecProgramGenerator pgen = new IecProgramGenerator();
		for (e : resource.allContents.toIterable.filter(ProgramConfiguration)) {
			s += pgen.compileProgramMemoryInit(e);
		}

		s += "return 0;
}

/**
 	function implementations
*/
"
		for (e : resource.allContents.toIterable.filter(FunctionDeclaration)) {
			s += fgen.compileFunctionDeclarationImplementation(e);
		}

		s += "	
/**
 	function_block implementations
*/
"
		for (e : resource.allContents.toIterable.filter(FunctionBlockDeclaration)) {
			s += fbgen.compileFunctionBlockDeclarationImplementation(e);
		}

		s += "

/**
 	programs declarations
*/
"
		for (e : resource.allContents.toIterable.filter(ProgramDeclaration)) {
			pgen.prog = e;
			s += pgen.compileProgramDeclarationImplementation(e);
		}
		s += "

/**
 	programs executions
*/
"
		var Iterable<TaskConfiguration> tasks = resource.allContents.toIterable.filter(TaskConfiguration);
		for (e : resource.allContents.toIterable.filter(ProgramConfiguration)) {
			s += pgen.compileProgramConfiguration(e, tasks);
		}
		fsa.generateFile(resource.URI.lastSegment.replace('.iec', '.c'), s)

	/**
	 *    generate header file for types
	 */
//		s = "#ifndef IEC_TYPES_H_
//#define IEC_TYPES_H_ 1
//
//#include <time.h>
//#include <stdlib.h>
//#include <stdio.h>
//
//#include \"comet_ua_iec_datapoints.h\"
//#include \"headers.h\"
//
//// customer type definitions
//"
//		var IecTypesGenerator typesgen = new IecTypesGenerator();
//		datatypes += typesgen.compileHeader
//		// for (e : resource.allContents.toIterable.filter(FunctionBlockDeclaration)) {
//		// datatypes += fbgen.compileFunctionBlockStructPrototype(e);
//		// }
//		for (e : resource.allContents.toIterable.filter(DataTypeDeclaration)) {
//			datatypes += typesgen.compileTypeDefinition(e)
//		}
//
//		s += "
//#endif // IEC_TYPES_H_"
//
//		fsa.generateFile(resource.URI.lastSegment.replace('.iec', '') + '_types.h', datatypes)
	}

	/** ************************************************************************************
	 * 
	 *  start generate code for all generic types
	 * 
	 ************************************************************************************ */
	def dispatch compileGenericType(StringType type) '''
STRING '''

	/**
	 * write out generic datatype
	 */
	def dispatch compileGenericType(GenericType type) {
		if (type.typeName !== null) {
			actIncrement = IEC_INT_SIZE;
			return type.typeName;
		}
	}

//	 '''
//«IF type.typeName != null»
//«type.typeName»«ENDIF»'''
	/**
	 * write out date datatype
	 */
	def dispatch compileGenericType(DateType type) '''
«IF type.typeName != null»
«type.typeName»«ENDIF»'''

	/**
	 * write out bit string datatype
	 */
	def dispatch compileGenericType(BitStringType type) '''
«IF type.typeName != null»
«type.typeName»«ENDIF»'''

	/**
	 * write out plain integer datatype
	 */
	def dispatch compileGenericType(PlainIntegerType type) {
		actReplaceMent = "";
		if (type.typeName !== null) {
			actIncrement = IEC_INT_SIZE;
			return type.typeName;
		}
	}

//	 '''
//«IF type.typeName != null»
//«type.typeName»«ENDIF»'''
	/**
	 * write out signed integer datatype
	 */
	def dispatch compileGenericType(SignedIntegerType type) {
		actReplaceMent = "";
		if (type.typeName !== null) {
			if (type.typeName.compareTo("INT") == 0) {
				actIncrement = IEC_INT_SIZE;
			}
			if (type.typeName.compareTo("SINT") == 0) {
				actIncrement = IEC_SINT_SIZE;
			}
			if (type.typeName.compareTo("LINT") == 0) {
				actIncrement = IEC_LINT_SIZE;
			}
			if (type.typeName.compareTo("DINT") == 0) {
				actIncrement = IEC_DINT_SIZE;
			}
			return type.typeName;
		} else {
			return "INT";
		}
	}

//«IF type.typeName != null»
//	«type.typeName»
//	«IF type.typeName.compareTo("SINT") == 0»
//		«actMemIndex += IEC_SINT_SIZE»
//	«ENDIF»
//«ELSE»INT«ENDIF»'''
	/**
	 * write out unsigned integer datatype
	 */
	def dispatch compileGenericType(UnsignedIntegerType type) {
		actReplaceMent = "";
		if (type.typeName !== null) {
			if (type.typeName.compareTo("UINT") == 0) {
				actIncrement = IEC_UINT_SIZE;
			}
			if (type.typeName.compareTo("USINT") == 0) {
				actIncrement = IEC_USINT_SIZE;
			}
			if (type.typeName.compareTo("ULINT") == 0) {
				actIncrement = IEC_ULINT_SIZE;
			}
			if (type.typeName.compareTo("UDINT") == 0) {
				actIncrement = IEC_UDINT_SIZE;
			}
			return type.typeName;
		}
	}

//	def dispatch compileGenericType(UnsignedIntegerType type) '''
//«IF type.typeName != null»
//«type.typeName»«ENDIF»'''
	/**
	 * write out real datatype
	 */
	def dispatch compileGenericType(RealType type) {
		actReplaceMent = "";
		if (type.typeName !== null) {
			if (type.typeName.compareTo("REAL") == 0) {
				actIncrement = IEC_REAL_SIZE;
			}
			if (type.typeName.compareTo("LREAL") == 0) {
				actIncrement = IEC_LREAL_SIZE;
			}

			return type.typeName;
		}
	}

//	 '''
//«IF type.typeName != null»
//«type.typeName»«ENDIF»'''
	/**
	 * write out derived datatype
	 */
	def dispatch compileGenericType(DerivedType type)
	{
		if (type.name !== null) {
//			if (type.name.compareTo("TON") == 0) {
//				actIncrement = IEC_LREAL_SIZE;
//			}
			actReplaceMent = "sizeof("+type.name+")";
			actIncrement = IEC_INT_SIZE;
			return type.name;
		}
	}
//	 '''
//«IF type.name.compareTo("TON") == 0»
//TON«ELSE»
//«type.name»«ENDIF»'''

	def dispatch compileGenericType(NumericType type) '''
'''

	def dispatch compileGenericType(ElementaryType type) '''
«IF type.typeName != null»
«type.typeName»«ENDIF»'''

	/**
	 * base data type function
	 */
	def dispatch compileGenericType(NonGenericType type) '''
'''

	/** ************************************************************************************
	 * 
	 *  end generate code for all generic types
	 * 
	 * ************************************************************************************ */
	/** ************************************************************************************
	 * 
	 *  start generate code for all variable initialization
	 * 
	 * ************************************************************************************ */
	/**
	 * write out initial value for integer data type
	 */
	def dispatch compileInitialElement(IntegerLiteral element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileInitialElement(RealLiteral element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileInitialElement(CharacterString element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileInitialElement(DurationLiteral element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileInitialElement(TimeOfDayLiteral element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileInitialElement(DateLiteral element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileInitialElement(DateAndTimeLiteral element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	def dispatch compileDefaultInitialValue(IntegerType element) '''0'''

	def dispatch compileDefaultInitialValue(RealType element) '''0.0'''

	def dispatch compileDefaultInitialValue(CharacterString element) '''""'''

	def dispatch compileDefaultInitialValue(BitStringType element) '''
«IF element.typeName.compareTo("BOOL") == 0»
FALSE«ELSE»0«ENDIF»'''

	def dispatch compileDefaultInitialValue(ElementaryType element) '''0'''

	/**
	 * write out initial value for bit string
	 */
	def dispatch compileInitialElement(BitString element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	/**
	 * write out initial value for boolean
	 */
	def dispatch compileInitialElement(Boolean element) '''
«IF element != null»«element.bodyExpression»«ENDIF»'''

	/**
	 * write out initial value for structure
	 */
	def dispatch compileInitialElement(StructureInitialization element) '''
{
	«FOR elem : element.initialElements»
.«elem.name» : «elem.value.compileInitialElement»
«IF !elem.equals(element.initialElements.get(0))»
, 
«ENDIF»
«ENDFOR»
}'''

	/**
	 * write out initial value for array
	 */
	def dispatch compileInitialElement(ArrayInitialization element) '''
«FOR els : element.initialElements»
«IF !element.initialElements.get(0).equals(els)»
,«ENDIF» «els.initialElement.compileInitialElement»«ENDFOR»'''

	/**
	 * base initial value function
	 */
	def dispatch compileInitialElement(InitialElement element) '''
'''

	/** ************************************************************************************
	 * 
	 *  end generate code for all variable initialization
	 * 
	 * ************************************************************************************ */
	def dispatch compileInitSymbolicVariableAccess(NamedVariableAccess access) '''
&«access.namedVariable.name»
'''

	def dispatch compileInitSymbolicVariableAccess(SymbolicVariableAccess access) '''
'''

	def dispatch compileSymbolicVariableAccess(NamedVariableAccess access) '''
«access.namedVariable.name»'''

	def dispatch compileSymbolicVariableAccess(SymbolicVariableAccess access) '''
'''

	/**
	 *  start generate code for all input variable declarations for function and function_block
	 */
	def dispatch compileVarDeclarations(VarDeclarations input) '''
«FOR decl : input.initDecls»
«FOR v : decl.var1List.variables»
«decl.specInit.baseType.compileGenericType» «v.name»;
«ENDFOR»
«ENDFOR»
'''

	def dispatch compileVarDeclarations(InputDeclarations input) '''
«FOR decl : input.declarations»
«FOR v : decl.var1List.variables»
«decl.declSpecification.compileDeclSpecification» «v.name»;
«ENDFOR»
«ENDFOR»
'''

	def dispatch compileVarDeclarations(InputOutputDeclarations input) '''
«FOR decl : input.initDecls»
«FOR v : decl.var1List.variables»
«decl.specInit.baseType.compileGenericType» «v.name»;
«ENDFOR»
«ENDFOR»
'''

	def dispatch compileVarDeclarations(OutputDeclarations input) '''
«FOR decl : input.initDecls»
«FOR v : decl.var1List.variables»
«decl.specInit.baseType.compileGenericType» «v.name»;
«ENDFOR»
«ENDFOR»
'''

	/**
	 *  end generate code for all variable declarations
	 */
	/**
	 *  start generate code for var decl specification
	 */
	def dispatch compileDeclSpecification(VarDeclSpecification spec) '''
«spec.specInit.baseType.compileGenericType»'''

	def dispatch compileDeclSpecification(EdgeDeclSpecification spec) '''
BOOL'''

	def dispatch compileDeclSpecification(DeclSpecification spec) '''
'''

	def dispatch compileInitializeVars(FunctionBlockVarDeclarations vars) '''
'''

	def dispatch compileInitializeVars(IoVarDeclarations decl) '''
'''

	def dispatch compileInitializeVars(InputDeclarations decl) '''
«IF decl.declarations != null»
«FOR d : decl.declarations»
«IF d.declSpecification != null»
«compileDeclInit(d.var1List, d.declSpecification)»
«ENDIF»
«ENDFOR»«ENDIF»'''

	def dispatch compileInitializeVars(OutputDeclarations decl) '''
«IF decl.initDecls != null»
«FOR d : decl.initDecls»
«IF d.specInit != null && d.specInit.constant != null»
«FOR v : d.var1List.variables»
value->«v.name»=«d.specInit.constant.compileInitialElement»;
«ENDFOR»
«ENDIF»
«ENDFOR»«ENDIF»'''

	def dispatch compileInitializeVars(InputOutputDeclarations decl) '''
«IF decl.initDecls != null»
«FOR d : decl.initDecls»
«IF d.specInit != null && d.specInit.constant != null»
«FOR v : d.var1List.variables»
value->«v.name»=«d.specInit.constant.compileInitialElement»;
«ENDFOR»
«ELSE»
«ENDIF»
«ENDFOR»«ENDIF»'''

	def dispatch compileInitializeVars(VarDeclarations decl) '''
«IF decl.initDecls != null»
«FOR d : decl.initDecls»
«IF d.specInit != null && d.specInit.constant != null»
«FOR v : d.var1List.variables»
value->«v.name»=«d.specInit.constant.compileInitialElement»;
«ENDFOR»
«ENDIF»
«ENDFOR»«ENDIF»'''

	def dispatch compileDeclInit(Var1List vars, VarDeclSpecification spec) '''
«FOR v : vars.variables»
«IF spec.specInit != null && spec.specInit.constant != null»
value->«v.name» = «spec.specInit.constant.compileInitialElement»;
«ENDIF»
«ENDFOR»
'''

	def dispatch compileDeclInit(Var1List vars, EdgeDeclSpecification spec) '''
'''

	def dispatch compileDeclInit(Var1List vars, DeclSpecification spec) '''
'''

	def private String initializeRange(int count, String value) {
		var String ret = " = {";
		var String del = "";
//«FOR i : 0..<range»«decl.constant» «ENDFOR» }"
		for (i : 0 ..< count) {
			ret += del + value;
			del = ", ";
		}
		ret += "}";
		return ret;
	}

	/***
	 * 		body code generation
	 * 
	 */
	def dispatch bodyVariableAccess(ArrayVariable access) '''
«access.subscriptedVariable.name»[«access.subscripts.get(0)»]'''

	def dispatch bodyVariableAccess(StructuredVariable access) '''
value->«access.recordVariable.name»«access.fieldSelector»'''

	def dispatch bodyVariableAccess(MultiElementVariable access) '''
'''

	def dispatch bodyVariableAccess(NamedVariableAccess access) '''
«IF prog != null»
«compilePointerFlag(prog, access.namedVariable.name)»«ENDIF»value->«access.namedVariable.name»'''

	def dispatch bodyVariableAccess(SymbolicVariableAccess access) '''
'''

	def dispatch bodyVariableAccess(DirectVariable access) '''
«IF prog != null»
«compilePointerFlag(prog, access.name)»«ENDIF»value->«access.name»'''

	def dispatch bodyVariableAccess(VariableAccess access) '''
'''

	def dispatch bodyExpression(IntegerLiteral exp) '''
«exp.value»'''

	def dispatch bodyExpression(RealLiteral exp) '''
«exp.value»'''

	def dispatch bodyExpression(CharacterString exp) '''
«exp.value»'''

	def dispatch bodyExpression(DurationLiteral exp) '''
«exp.duration.generateDuration»'''

	def dispatch bodyExpression(TimeOfDayLiteral exp) '''
«exp.generateTimeOfDay»'''

	def dispatch bodyExpression(DateLiteral exp) '''
«exp.generateDate»'''

	def dispatch bodyExpression(DateAndTimeLiteral exp) '''
«exp.generateDateAndTime»'''

	def dispatch bodyExpression(BinaryExpression exp) '''
«exp.left.bodyExpression» «exp.operator.replace("MOD", "%").replace(">=", "ge").replace("<=", "le").replace("=", "==").replace("le", ">=").replace("ge", ">=").replace("<>", "!").replace("&", "&&").replace("AND", "&&").replace("OR", "||").replace("XOR", "!")» «exp.right.bodyExpression»'''

	def dispatch bodyExpression(UnaryExpression exp) '''
«exp.operator»«exp.expression.bodyExpression»'''

	def dispatch bodyExpression(Boolean exp) '''
«IF exp.boolInt != null»«exp.boolInt»«ELSE»«exp.^true»«ENDIF»'''

	def dispatch bodyExpression(Expression exp) '''
«IF exp.fbname != null»func_«exp.fbname.name»«ENDIF»«exp.openbr»«IF exp.variable != null»«exp.variable.bodyVariableAccess»«ENDIF»«IF exp.expression != null»«exp.expression.bodyExpression»«ENDIF»«exp.closebr»'''

	def dispatch bodyStateMent(SelectionStatement state) '''
'''

	def dispatch bodyStateMent(IfStatement state) '''
if («state.ifExpression.bodyExpression»)
{
	«state.thenStatementList.bodyBody»
}
«IF state.elseIfs != null»
«FOR elif : state.elseIfs»
«elif.bodyElseIF»
«ENDFOR»
«ENDIF»
«IF state.elseStatementList != null»
else
{
	«state.elseStatementList.bodyBody»
}
«ENDIF»
'''

	def dispatch bodyBody(InstructionList body) '''
«FOR inst : body.instructions»
«inst.bodyInstruction»«ENDFOR»'''

	def dispatch bodyBody(StatementList body) '''
«FOR state : body.statements»
«state.bodyStateMent»«ENDFOR»'''

	def bodyElseIF(ElseIf elseif) '''
else if («elseif.expression.bodyExpression»)
{
	«elseif.statementList.bodyBody»
}
'''

	def dispatch bodyStateMent(CaseStatement state) '''
switch(«state.expression.bodyExpression»)
{
	«FOR elems : state.caseElements»
	«elems.bodyCaseElement»
	«ENDFOR»
	«IF state.elseStatementList != null»
	default:
	«state.elseStatementList.bodyBody»
	break;
	«ENDIF»
}
'''

	/**
	 * wite out one case label
	 */
	def bodyCaseListElement(CaseListElement elem) '''
«IF elem.subRange != null»
«elem.subRange.writeCaseSubRange»«ELSEIF elem.integer != null»
case «elem.integer»:«ELSEIF elem.enumeratedValue != null»
case «elem.enumeratedValue»:«ENDIF»'''

	/**
	 * write out one case statement from case to break;
	 */
	def bodyCaseElement(CaseElement elem) '''
«FOR el : elem.caseList.elements»«el.bodyCaseListElement»
«ENDFOR»
«elem.statementList.bodyBody»
break;
'''

	/**
	 * write out a single assignment statement
	 * we have to check if we have a var_access variable or a simple variable
	 */
	def dispatch bodyStateMent(AssignStatement state) '''
«IF state.expression.fbname != null»
value->«state.variable.name» =;
«ENDIF»
«IF prog != null»
«compilePointerFlag(prog, state.variable.name)»«ENDIF»value->«state.variable.name» = «state.expression.bodyExpression»;
'''

	def dispatch compilePointerFlag(EObject prog, String variable) '''
'''

	/**
	 * base body statement function
	 */
	def dispatch bodyStateMent(Statement state) '''
'''

	def dispatch bodyVariable(DirectVariable access) '''
«access.name»
'''

	def dispatch bodyVariable(SymbolicVariableAccess access) '''
'''

	def dispatch bodyVariable(NamedVariableAccess access) '''
«access.namedVariable.name»
'''

	def dispatch bodyVariable(ArrayVariable access) '''
«access.subscriptedVariable.name»
«FOR sub : access.subscripts»
«sub.bodyExpression»
«ENDFOR»
'''

	def dispatch bodyVariable(StructuredVariable access) '''
«access.recordVariable.name»«access.fieldSelector»
'''

	def dispatch bodyVariable(Identifier access) '''
«access»
'''

	def bodyInstruction(Instruction inst) '''
'''

	def String writeCaseSubRange(String input) {
		var String ret = "";
		if (input != null) {
			var String start = input.substring(0, input.indexOf("."));
			var String end = input.substring(input.lastIndexOf(".") + 1);

			var int s = Integer.parseInt(start);
			var int e = Integer.parseInt(end);

			var int min = Math.min(s, e);
			var int max = Math.max(s, e);
			for (i : min .. max) {
				ret += "case " + i + ":\n";
			}
		}
		return ret;
	}

	def String generateDuration(String duration) {
		var String dur = duration;
		var long value = 0;

		if (duration.contains("d")) {
			value = Long.parseLong(dur.substring(0, dur.indexOf("d"))) * 24 * 60 * 60 * 1000;
			dur = dur.substring(dur.indexOf("d") + 1);
		}
		if (duration.contains("h")) {
			value += Long.parseLong(dur.substring(0, dur.indexOf("h"))) * 60 * 60 * 1000;
			dur = dur.substring(dur.indexOf("h") + 1);
		}
		if (duration.contains("m")) {
			value += Long.parseLong(dur.substring(0, dur.indexOf("m"))) * 60 * 1000;
			dur = dur.substring(dur.indexOf("m") + 1);
		}
		if (duration.contains("s")) {
			value += Long.parseLong(dur.substring(0, dur.indexOf("s"))) * 1000;
			dur = dur.substring(dur.indexOf("s") + 1);
		}
		if (duration.contains("ms")) {
			value += Long.parseLong(dur.substring(0, dur.indexOf("ms")));
		}
		return value + "";
	}

	def String generateTimeOfDay(TimeOfDayLiteral timeofDay) {

		var long value = Long.parseLong(timeofDay.hour) * 60 * 60 * 1000;
		value += Long.parseLong(timeofDay.minute) * 60 * 1000;
		value += Long.parseLong(timeofDay.second) * 1000;
		return value + "";

	}

	def String generateDate(DateLiteral date) {

		var GregorianCalendar gcalendar = new GregorianCalendar();
		gcalendar.set(Integer.parseInt(date.year), Integer.parseInt(date.month), Integer.parseInt(date.day));

		return gcalendar.timeInMillis + "";

	}

	def String generateDateAndTime(DateAndTimeLiteral date) {

		var GregorianCalendar gcalendar = new GregorianCalendar();
		gcalendar.set(Integer.parseInt(date.year), Integer.parseInt(date.month), Integer.parseInt(date.day),
			Integer.parseInt(date.hour), Integer.parseInt(date.minute), Integer.parseInt(date.second));

		return gcalendar.timeInMillis + "";

	}
}
