/*
 * generated by Xtext
 */
package com.bichler.iec.serializer;

import com.bichler.iec.iec.ArrayDeclaration;
import com.bichler.iec.iec.ArrayInitialElements;
import com.bichler.iec.iec.ArrayInitialization;
import com.bichler.iec.iec.ArrayVariable;
import com.bichler.iec.iec.AssignStatement;
import com.bichler.iec.iec.BinaryExpression;
import com.bichler.iec.iec.BitString;
import com.bichler.iec.iec.BitStringType;
import com.bichler.iec.iec.CaseElement;
import com.bichler.iec.iec.CaseList;
import com.bichler.iec.iec.CaseListElement;
import com.bichler.iec.iec.CaseStatement;
import com.bichler.iec.iec.CharacterString;
import com.bichler.iec.iec.ConfigurationDeclaration;
import com.bichler.iec.iec.DataSink;
import com.bichler.iec.iec.DataTypeDeclaration;
import com.bichler.iec.iec.DateAndTimeLiteral;
import com.bichler.iec.iec.DateLiteral;
import com.bichler.iec.iec.DateType;
import com.bichler.iec.iec.DerivedType;
import com.bichler.iec.iec.DirectVariable;
import com.bichler.iec.iec.DurationLiteral;
import com.bichler.iec.iec.EdgeDeclSpecification;
import com.bichler.iec.iec.EdgeDeclaration;
import com.bichler.iec.iec.ElementaryType;
import com.bichler.iec.iec.ElseIf;
import com.bichler.iec.iec.EnumDeclaration;
import com.bichler.iec.iec.EnumeratedValue;
import com.bichler.iec.iec.Enumeration;
import com.bichler.iec.iec.Expression;
import com.bichler.iec.iec.ExpressionOperation;
import com.bichler.iec.iec.FBTask;
import com.bichler.iec.iec.FunctionBlockDeclaration;
import com.bichler.iec.iec.FunctionDeclaration;
import com.bichler.iec.iec.GenericType;
import com.bichler.iec.iec.GlobalVar;
import com.bichler.iec.iec.GlobalVarDecl;
import com.bichler.iec.iec.GlobalVarDeclarations;
import com.bichler.iec.iec.GlobalVarList;
import com.bichler.iec.iec.GlobalVarSpec;
import com.bichler.iec.iec.IecPackage;
import com.bichler.iec.iec.IfStatement;
import com.bichler.iec.iec.InitializedStructure;
import com.bichler.iec.iec.InputDeclaration;
import com.bichler.iec.iec.InputDeclarations;
import com.bichler.iec.iec.InputOutputDeclarations;
import com.bichler.iec.iec.Instruction;
import com.bichler.iec.iec.InstructionList;
import com.bichler.iec.iec.IntegerLiteral;
import com.bichler.iec.iec.JmpOperation;
import com.bichler.iec.iec.Label;
import com.bichler.iec.iec.LocatedVarDeclaration;
import com.bichler.iec.iec.LocatedVarDeclarations;
import com.bichler.iec.iec.Location;
import com.bichler.iec.iec.Model;
import com.bichler.iec.iec.NamedVariableAccess;
import com.bichler.iec.iec.Operand;
import com.bichler.iec.iec.OutputDeclarations;
import com.bichler.iec.iec.ParamAssignment;
import com.bichler.iec.iec.ProgCNXN;
import com.bichler.iec.iec.ProgConfElements;
import com.bichler.iec.iec.ProgramAccessDecl;
import com.bichler.iec.iec.ProgramAccessDecls;
import com.bichler.iec.iec.ProgramConfiguration;
import com.bichler.iec.iec.ProgramDeclaration;
import com.bichler.iec.iec.RangeDeclaration;
import com.bichler.iec.iec.RealLiteral;
import com.bichler.iec.iec.RealType;
import com.bichler.iec.iec.ResourceDeclaration;
import com.bichler.iec.iec.SignedIntegerType;
import com.bichler.iec.iec.SimpleInstructionList;
import com.bichler.iec.iec.SimpleOperation;
import com.bichler.iec.iec.SimpleTypeDeclaration;
import com.bichler.iec.iec.SingleResourceDeclaration;
import com.bichler.iec.iec.SpecInit;
import com.bichler.iec.iec.StatementList;
import com.bichler.iec.iec.StringDeclaration;
import com.bichler.iec.iec.StringType;
import com.bichler.iec.iec.StructureDeclaration;
import com.bichler.iec.iec.StructureElementDeclaration;
import com.bichler.iec.iec.StructureElementInitialization;
import com.bichler.iec.iec.StructureInitialization;
import com.bichler.iec.iec.StructureTypeDeclaration;
import com.bichler.iec.iec.StructuredVariable;
import com.bichler.iec.iec.TaskConfiguration;
import com.bichler.iec.iec.TaskInitialization;
import com.bichler.iec.iec.TimeOfDayLiteral;
import com.bichler.iec.iec.UnaryExpression;
import com.bichler.iec.iec.UnsignedIntegerType;
import com.bichler.iec.iec.Var1List;
import com.bichler.iec.iec.VarDeclSpecification;
import com.bichler.iec.iec.VarDeclarations;
import com.bichler.iec.iec.VarInitDecl;
import com.bichler.iec.iec.Variable;
import com.bichler.iec.services.IecGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IecSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IecGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IecPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IecPackage.ARRAY_DECLARATION:
				sequence_ArrayDeclaration(context, (ArrayDeclaration) semanticObject); 
				return; 
			case IecPackage.ARRAY_INITIAL_ELEMENTS:
				sequence_ArrayInitialElements(context, (ArrayInitialElements) semanticObject); 
				return; 
			case IecPackage.ARRAY_INITIALIZATION:
				sequence_ArrayInitialization(context, (ArrayInitialization) semanticObject); 
				return; 
			case IecPackage.ARRAY_VARIABLE:
				sequence_ArrayVariable(context, (ArrayVariable) semanticObject); 
				return; 
			case IecPackage.ASSIGN_STATEMENT:
				sequence_AssignStatement(context, (AssignStatement) semanticObject); 
				return; 
			case IecPackage.BINARY_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AddExpression_AndExpression_Comparison_OrExpression_PowerExpression_Term_XorExpression(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AddExpression_AndExpression_Comparison_PowerExpression_Term(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AddExpression_AndExpression_Comparison_PowerExpression_Term_XorExpression(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AddExpression_Comparison_PowerExpression_Term(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAddExpressionRule()
						|| action == grammarAccess.getAddExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AddExpression_PowerExpression_Term(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPowerExpressionRule()
						|| action == grammarAccess.getPowerExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_PowerExpression(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_PowerExpression_Term(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else break;
			case IecPackage.BIT_STRING:
				sequence_BitString(context, (BitString) semanticObject); 
				return; 
			case IecPackage.BIT_STRING_TYPE:
				sequence_BitStringType(context, (BitStringType) semanticObject); 
				return; 
			case IecPackage.BOOLEAN:
				sequence_Boolean(context, (com.bichler.iec.iec.Boolean) semanticObject); 
				return; 
			case IecPackage.CASE_ELEMENT:
				sequence_CaseElement(context, (CaseElement) semanticObject); 
				return; 
			case IecPackage.CASE_LIST:
				sequence_CaseList(context, (CaseList) semanticObject); 
				return; 
			case IecPackage.CASE_LIST_ELEMENT:
				sequence_CaseListElement(context, (CaseListElement) semanticObject); 
				return; 
			case IecPackage.CASE_STATEMENT:
				sequence_CaseStatement(context, (CaseStatement) semanticObject); 
				return; 
			case IecPackage.CHARACTER_STRING:
				sequence_CharacterString(context, (CharacterString) semanticObject); 
				return; 
			case IecPackage.CONFIGURATION_DECLARATION:
				sequence_ConfigurationDeclaration(context, (ConfigurationDeclaration) semanticObject); 
				return; 
			case IecPackage.DATA_SINK:
				sequence_DataSink(context, (DataSink) semanticObject); 
				return; 
			case IecPackage.DATA_TYPE_DECLARATION:
				sequence_DataTypeDeclaration(context, (DataTypeDeclaration) semanticObject); 
				return; 
			case IecPackage.DATE_AND_TIME_LITERAL:
				sequence_DateAndTimeLiteral(context, (DateAndTimeLiteral) semanticObject); 
				return; 
			case IecPackage.DATE_LITERAL:
				sequence_DateLiteral(context, (DateLiteral) semanticObject); 
				return; 
			case IecPackage.DATE_TYPE:
				sequence_DateType(context, (DateType) semanticObject); 
				return; 
			case IecPackage.DERIVED_TYPE:
				sequence_DerivedType(context, (DerivedType) semanticObject); 
				return; 
			case IecPackage.DIRECT_VARIABLE:
				sequence_DirectVariable(context, (DirectVariable) semanticObject); 
				return; 
			case IecPackage.DURATION_LITERAL:
				sequence_DurationLiteral(context, (DurationLiteral) semanticObject); 
				return; 
			case IecPackage.EDGE_DECL_SPECIFICATION:
				sequence_EdgeDeclSpecification(context, (EdgeDeclSpecification) semanticObject); 
				return; 
			case IecPackage.EDGE_DECLARATION:
				sequence_EdgeDeclaration(context, (EdgeDeclaration) semanticObject); 
				return; 
			case IecPackage.ELEMENTARY_TYPE:
				sequence_ElementaryType(context, (ElementaryType) semanticObject); 
				return; 
			case IecPackage.ELSE_IF:
				sequence_ElseIf(context, (ElseIf) semanticObject); 
				return; 
			case IecPackage.ENUM_DECLARATION:
				sequence_EnumDeclaration(context, (EnumDeclaration) semanticObject); 
				return; 
			case IecPackage.ENUMERATED_VALUE:
				sequence_EnumeratedValue(context, (EnumeratedValue) semanticObject); 
				return; 
			case IecPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case IecPackage.EXPRESSION:
				if (rule == grammarAccess.getParenthesesExpressionRule()) {
					sequence_ParenthesesExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAddExpressionRule()
						|| action == grammarAccess.getAddExpressionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPowerExpressionRule()
						|| action == grammarAccess.getPowerExpressionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_ParenthesesExpression_PrimaryExpression(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case IecPackage.EXPRESSION_OPERATION:
				sequence_ExpressionOperation(context, (ExpressionOperation) semanticObject); 
				return; 
			case IecPackage.FB_TASK:
				sequence_FBTask(context, (FBTask) semanticObject); 
				return; 
			case IecPackage.FUNCTION_BLOCK_DECLARATION:
				sequence_FunctionBlockDeclaration(context, (FunctionBlockDeclaration) semanticObject); 
				return; 
			case IecPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case IecPackage.GENERIC_TYPE:
				sequence_GenericType(context, (GenericType) semanticObject); 
				return; 
			case IecPackage.GLOBAL_VAR:
				sequence_GlobalVar(context, (GlobalVar) semanticObject); 
				return; 
			case IecPackage.GLOBAL_VAR_DECL:
				sequence_GlobalVarDecl(context, (GlobalVarDecl) semanticObject); 
				return; 
			case IecPackage.GLOBAL_VAR_DECLARATIONS:
				sequence_GlobalVarDeclarations(context, (GlobalVarDeclarations) semanticObject); 
				return; 
			case IecPackage.GLOBAL_VAR_LIST:
				sequence_GlobalVarList(context, (GlobalVarList) semanticObject); 
				return; 
			case IecPackage.GLOBAL_VAR_SPEC:
				sequence_GlobalVarSpec(context, (GlobalVarSpec) semanticObject); 
				return; 
			case IecPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case IecPackage.INITIALIZED_STRUCTURE:
				sequence_InitializedStructure(context, (InitializedStructure) semanticObject); 
				return; 
			case IecPackage.INPUT_DECLARATION:
				sequence_InputDeclaration(context, (InputDeclaration) semanticObject); 
				return; 
			case IecPackage.INPUT_DECLARATIONS:
				sequence_InputDeclarations(context, (InputDeclarations) semanticObject); 
				return; 
			case IecPackage.INPUT_OUTPUT_DECLARATIONS:
				sequence_InputOutputDeclarations(context, (InputOutputDeclarations) semanticObject); 
				return; 
			case IecPackage.INSTRUCTION:
				sequence_Instruction(context, (Instruction) semanticObject); 
				return; 
			case IecPackage.INSTRUCTION_LIST:
				sequence_InstructionList(context, (InstructionList) semanticObject); 
				return; 
			case IecPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case IecPackage.JMP_OPERATION:
				sequence_JmpOperation(context, (JmpOperation) semanticObject); 
				return; 
			case IecPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case IecPackage.LOCATED_VAR_DECLARATION:
				sequence_LocatedVarDeclaration(context, (LocatedVarDeclaration) semanticObject); 
				return; 
			case IecPackage.LOCATED_VAR_DECLARATIONS:
				sequence_LocatedVarDeclarations(context, (LocatedVarDeclarations) semanticObject); 
				return; 
			case IecPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case IecPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case IecPackage.NAMED_VARIABLE_ACCESS:
				sequence_NamedVariableAccess(context, (NamedVariableAccess) semanticObject); 
				return; 
			case IecPackage.OPERAND:
				sequence_Operand(context, (Operand) semanticObject); 
				return; 
			case IecPackage.OUTPUT_DECLARATIONS:
				sequence_OutputDeclarations(context, (OutputDeclarations) semanticObject); 
				return; 
			case IecPackage.PARAM_ASSIGNMENT:
				sequence_ParamAssignment(context, (ParamAssignment) semanticObject); 
				return; 
			case IecPackage.PROG_CNXN:
				sequence_ProgCNXN(context, (ProgCNXN) semanticObject); 
				return; 
			case IecPackage.PROG_CONF_ELEMENTS:
				sequence_ProgConfElements(context, (ProgConfElements) semanticObject); 
				return; 
			case IecPackage.PROGRAM_ACCESS_DECL:
				sequence_ProgramAccessDecl(context, (ProgramAccessDecl) semanticObject); 
				return; 
			case IecPackage.PROGRAM_ACCESS_DECLS:
				sequence_ProgramAccessDecls(context, (ProgramAccessDecls) semanticObject); 
				return; 
			case IecPackage.PROGRAM_CONFIGURATION:
				sequence_ProgramConfiguration(context, (ProgramConfiguration) semanticObject); 
				return; 
			case IecPackage.PROGRAM_DECLARATION:
				sequence_ProgramDeclaration(context, (ProgramDeclaration) semanticObject); 
				return; 
			case IecPackage.RANGE_DECLARATION:
				sequence_RangeDeclaration(context, (RangeDeclaration) semanticObject); 
				return; 
			case IecPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case IecPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case IecPackage.RESOURCE_DECLARATION:
				sequence_ResourceDeclaration(context, (ResourceDeclaration) semanticObject); 
				return; 
			case IecPackage.SIGNED_INTEGER_TYPE:
				if (rule == grammarAccess.getPlainIntegerTypeRule()) {
					sequence_PlainIntegerType(context, (SignedIntegerType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getLibraryElementRule()
						|| rule == grammarAccess.getDataTypeRule()
						|| rule == grammarAccess.getNonGenericTypeRule()
						|| rule == grammarAccess.getElementaryTypeRule()
						|| rule == grammarAccess.getNumericTypeRule()
						|| rule == grammarAccess.getIntegerTypeRule()) {
					sequence_PlainIntegerType_SignedIntegerType(context, (SignedIntegerType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSignedIntegerTypeRule()) {
					sequence_SignedIntegerType(context, (SignedIntegerType) semanticObject); 
					return; 
				}
				else break;
			case IecPackage.SIMPLE_INSTRUCTION_LIST:
				sequence_SimpleInstructionList(context, (SimpleInstructionList) semanticObject); 
				return; 
			case IecPackage.SIMPLE_OPERATION:
				sequence_SimpleOperation(context, (SimpleOperation) semanticObject); 
				return; 
			case IecPackage.SIMPLE_TYPE_DECLARATION:
				sequence_SimpleTypeDeclaration(context, (SimpleTypeDeclaration) semanticObject); 
				return; 
			case IecPackage.SINGLE_RESOURCE_DECLARATION:
				sequence_SingleResourceDeclaration(context, (SingleResourceDeclaration) semanticObject); 
				return; 
			case IecPackage.SPEC_INIT:
				sequence_SpecInit(context, (SpecInit) semanticObject); 
				return; 
			case IecPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case IecPackage.STRING_DECLARATION:
				sequence_StringDeclaration(context, (StringDeclaration) semanticObject); 
				return; 
			case IecPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case IecPackage.STRUCTURE_DECLARATION:
				sequence_StructureDeclaration(context, (StructureDeclaration) semanticObject); 
				return; 
			case IecPackage.STRUCTURE_ELEMENT_DECLARATION:
				sequence_StructureElementDeclaration(context, (StructureElementDeclaration) semanticObject); 
				return; 
			case IecPackage.STRUCTURE_ELEMENT_INITIALIZATION:
				sequence_StructureElementInitialization(context, (StructureElementInitialization) semanticObject); 
				return; 
			case IecPackage.STRUCTURE_INITIALIZATION:
				sequence_StructureInitialization(context, (StructureInitialization) semanticObject); 
				return; 
			case IecPackage.STRUCTURE_TYPE_DECLARATION:
				sequence_StructureTypeDeclaration(context, (StructureTypeDeclaration) semanticObject); 
				return; 
			case IecPackage.STRUCTURED_VARIABLE:
				sequence_StructuredVariable(context, (StructuredVariable) semanticObject); 
				return; 
			case IecPackage.TASK_CONFIGURATION:
				sequence_TaskConfiguration(context, (TaskConfiguration) semanticObject); 
				return; 
			case IecPackage.TASK_INITIALIZATION:
				sequence_TaskInitialization(context, (TaskInitialization) semanticObject); 
				return; 
			case IecPackage.TIME_OF_DAY_LITERAL:
				sequence_TimeOfDayLiteral(context, (TimeOfDayLiteral) semanticObject); 
				return; 
			case IecPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case IecPackage.UNSIGNED_INTEGER_TYPE:
				sequence_UnsignedIntegerType(context, (UnsignedIntegerType) semanticObject); 
				return; 
			case IecPackage.VAR1_LIST:
				sequence_Var1List(context, (Var1List) semanticObject); 
				return; 
			case IecPackage.VAR_DECL_SPECIFICATION:
				sequence_VarDeclSpecification(context, (VarDeclSpecification) semanticObject); 
				return; 
			case IecPackage.VAR_DECLARATIONS:
				sequence_VarDeclarations(context, (VarDeclarations) semanticObject); 
				return; 
			case IecPackage.VAR_INIT_DECL:
				sequence_VarInitDecl(context, (VarInitDecl) semanticObject); 
				return; 
			case IecPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns BinaryExpression
	 *     OrExpression returns BinaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpression_BinaryExpression_1_0 operator='OR' right=XorExpression) | 
	 *         (left=XorExpression_BinaryExpression_1_0 operator='XOR' right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 (operator='&' | operator='AND') right=Comparison) | 
	 *         (
	 *             left=Comparison_BinaryExpression_1_0 
	 *             (
	 *                 operator='=' | 
	 *                 operator='<>' | 
	 *                 operator='<' | 
	 *                 operator='>' | 
	 *                 operator='<=' | 
	 *                 operator='>='
	 *             ) 
	 *             right=AddExpression
	 *         ) | 
	 *         (left=AddExpression_BinaryExpression_1_0 (operator='-' | operator='+') right=Term) | 
	 *         (left=Term_BinaryExpression_1_0 (operator='*' | operator='/' | operator='MOD') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_AddExpression_AndExpression_Comparison_OrExpression_PowerExpression_Term_XorExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns BinaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_BinaryExpression_1_0 (operator='&' | operator='AND') right=Comparison) | 
	 *         (
	 *             left=Comparison_BinaryExpression_1_0 
	 *             (
	 *                 operator='=' | 
	 *                 operator='<>' | 
	 *                 operator='<' | 
	 *                 operator='>' | 
	 *                 operator='<=' | 
	 *                 operator='>='
	 *             ) 
	 *             right=AddExpression
	 *         ) | 
	 *         (left=AddExpression_BinaryExpression_1_0 (operator='-' | operator='+') right=Term) | 
	 *         (left=Term_BinaryExpression_1_0 (operator='*' | operator='/' | operator='MOD') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_AddExpression_AndExpression_Comparison_PowerExpression_Term(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XorExpression returns BinaryExpression
	 *     XorExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=XorExpression_BinaryExpression_1_0 operator='XOR' right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 (operator='&' | operator='AND') right=Comparison) | 
	 *         (
	 *             left=Comparison_BinaryExpression_1_0 
	 *             (
	 *                 operator='=' | 
	 *                 operator='<>' | 
	 *                 operator='<' | 
	 *                 operator='>' | 
	 *                 operator='<=' | 
	 *                 operator='>='
	 *             ) 
	 *             right=AddExpression
	 *         ) | 
	 *         (left=AddExpression_BinaryExpression_1_0 (operator='-' | operator='+') right=Term) | 
	 *         (left=Term_BinaryExpression_1_0 (operator='*' | operator='/' | operator='MOD') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_AddExpression_AndExpression_Comparison_PowerExpression_Term_XorExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comparison returns BinaryExpression
	 *     Comparison.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             left=Comparison_BinaryExpression_1_0 
	 *             (
	 *                 operator='=' | 
	 *                 operator='<>' | 
	 *                 operator='<' | 
	 *                 operator='>' | 
	 *                 operator='<=' | 
	 *                 operator='>='
	 *             ) 
	 *             right=AddExpression
	 *         ) | 
	 *         (left=AddExpression_BinaryExpression_1_0 (operator='-' | operator='+') right=Term) | 
	 *         (left=Term_BinaryExpression_1_0 (operator='*' | operator='/' | operator='MOD') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_AddExpression_Comparison_PowerExpression_Term(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AddExpression returns BinaryExpression
	 *     AddExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AddExpression_BinaryExpression_1_0 (operator='-' | operator='+') right=Term) | 
	 *         (left=Term_BinaryExpression_1_0 (operator='*' | operator='/' | operator='MOD') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_AddExpression_PowerExpression_Term(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns ArrayDeclaration
	 *     ArrayDeclaration returns ArrayDeclaration
	 *
	 * Constraint:
	 *     (derivedType=DerivedType ranges+=SubRangeWithSign ranges+=SubRangeWithSign* baseType=NonGenericType constant=ArrayInitialization?)
	 */
	protected void sequence_ArrayDeclaration(ISerializationContext context, ArrayDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayInitialElements returns ArrayInitialElements
	 *
	 * Constraint:
	 *     (initialElement=InitialElement | (index=Integer initialElement=InitialElement))
	 */
	protected void sequence_ArrayInitialElements(ISerializationContext context, ArrayInitialElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayInitialization returns ArrayInitialization
	 *     InitialElement returns ArrayInitialization
	 *
	 * Constraint:
	 *     (initialElements+=ArrayInitialElements initialElements+=ArrayInitialElements*)
	 */
	protected void sequence_ArrayInitialization(ISerializationContext context, ArrayInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableAccess returns ArrayVariable
	 *     SymbolicVariableAccess returns ArrayVariable
	 *     MultiElementVariable returns ArrayVariable
	 *     ArrayVariable returns ArrayVariable
	 *     ReferencedOperand returns ArrayVariable
	 *
	 * Constraint:
	 *     (subscriptedVariable=[Variable|Identifier] subscripts+=Expression subscripts+=Expression*)
	 */
	protected void sequence_ArrayVariable(ISerializationContext context, ArrayVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignStatement
	 *     AssignStatement returns AssignStatement
	 *
	 * Constraint:
	 *     (variable=[Variable|Identifier] expression=Expression)
	 */
	protected void sequence_AssignStatement(ISerializationContext context, AssignStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.ASSIGN_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.ASSIGN_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.ASSIGN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.ASSIGN_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignStatementAccess().getVariableVariableIdentifierParserRuleCall_0_0_1(), semanticObject.eGet(IecPackage.Literals.ASSIGN_STATEMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getAssignStatementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns BitStringType
	 *     LibraryElement returns BitStringType
	 *     DataType returns BitStringType
	 *     NonGenericType returns BitStringType
	 *     ElementaryType returns BitStringType
	 *     BitStringType returns BitStringType
	 *
	 * Constraint:
	 *     (typeName='BOOL' | typeName='BYTE' | typeName='WORD' | typeName='DWORD' | typeName='LWORD')
	 */
	protected void sequence_BitStringType(ISerializationContext context, BitStringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns BitString
	 *     Expression returns BitString
	 *     OrExpression returns BitString
	 *     OrExpression.BinaryExpression_1_0 returns BitString
	 *     XorExpression returns BitString
	 *     XorExpression.BinaryExpression_1_0 returns BitString
	 *     AndExpression returns BitString
	 *     AndExpression.BinaryExpression_1_0 returns BitString
	 *     Comparison returns BitString
	 *     Comparison.BinaryExpression_1_0 returns BitString
	 *     AddExpression returns BitString
	 *     AddExpression.BinaryExpression_1_0 returns BitString
	 *     Term returns BitString
	 *     Term.BinaryExpression_1_0 returns BitString
	 *     PowerExpression returns BitString
	 *     PowerExpression.BinaryExpression_1_0 returns BitString
	 *     UnaryExpression returns BitString
	 *     PrimaryExpression returns BitString
	 *     ProgDataSource returns BitString
	 *     DataSource returns BitString
	 *     Constant returns BitString
	 *     BitString returns BitString
	 *
	 * Constraint:
	 *     value=BitStringValue
	 */
	protected void sequence_BitString(ISerializationContext context, BitString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.BIT_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.BIT_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitStringAccess().getValueBitStringValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns Boolean
	 *     Expression returns Boolean
	 *     OrExpression returns Boolean
	 *     OrExpression.BinaryExpression_1_0 returns Boolean
	 *     XorExpression returns Boolean
	 *     XorExpression.BinaryExpression_1_0 returns Boolean
	 *     AndExpression returns Boolean
	 *     AndExpression.BinaryExpression_1_0 returns Boolean
	 *     Comparison returns Boolean
	 *     Comparison.BinaryExpression_1_0 returns Boolean
	 *     AddExpression returns Boolean
	 *     AddExpression.BinaryExpression_1_0 returns Boolean
	 *     Term returns Boolean
	 *     Term.BinaryExpression_1_0 returns Boolean
	 *     PowerExpression returns Boolean
	 *     PowerExpression.BinaryExpression_1_0 returns Boolean
	 *     UnaryExpression returns Boolean
	 *     PrimaryExpression returns Boolean
	 *     ProgDataSource returns Boolean
	 *     DataSource returns Boolean
	 *     Constant returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     (boolInt=Integer | true?='TRUE')?
	 */
	protected void sequence_Boolean(ISerializationContext context, com.bichler.iec.iec.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseElement returns CaseElement
	 *
	 * Constraint:
	 *     (caseList=CaseList statementList=StatementList)
	 */
	protected void sequence_CaseElement(ISerializationContext context, CaseElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.CASE_ELEMENT__CASE_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.CASE_ELEMENT__CASE_LIST));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.CASE_ELEMENT__STATEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.CASE_ELEMENT__STATEMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseElementAccess().getCaseListCaseListParserRuleCall_0_0(), semanticObject.getCaseList());
		feeder.accept(grammarAccess.getCaseElementAccess().getStatementListStatementListParserRuleCall_2_0(), semanticObject.getStatementList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseListElement returns CaseListElement
	 *
	 * Constraint:
	 *     (subRange=SUB_RANGE | integer=SignedInteger | enumeratedValue=[EnumeratedValue|Identifier])
	 */
	protected void sequence_CaseListElement(ISerializationContext context, CaseListElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseList returns CaseList
	 *
	 * Constraint:
	 *     (elements+=CaseListElement elements+=CaseListElement*)
	 */
	protected void sequence_CaseList(ISerializationContext context, CaseList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CaseStatement
	 *     SelectionStatement returns CaseStatement
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (expression=Expression caseElements+=CaseElement* elseStatementList=StatementList?)
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns CharacterString
	 *     Expression returns CharacterString
	 *     OrExpression returns CharacterString
	 *     OrExpression.BinaryExpression_1_0 returns CharacterString
	 *     XorExpression returns CharacterString
	 *     XorExpression.BinaryExpression_1_0 returns CharacterString
	 *     AndExpression returns CharacterString
	 *     AndExpression.BinaryExpression_1_0 returns CharacterString
	 *     Comparison returns CharacterString
	 *     Comparison.BinaryExpression_1_0 returns CharacterString
	 *     AddExpression returns CharacterString
	 *     AddExpression.BinaryExpression_1_0 returns CharacterString
	 *     Term returns CharacterString
	 *     Term.BinaryExpression_1_0 returns CharacterString
	 *     PowerExpression returns CharacterString
	 *     PowerExpression.BinaryExpression_1_0 returns CharacterString
	 *     UnaryExpression returns CharacterString
	 *     PrimaryExpression returns CharacterString
	 *     ProgDataSource returns CharacterString
	 *     DataSource returns CharacterString
	 *     Constant returns CharacterString
	 *     CharacterString returns CharacterString
	 *
	 * Constraint:
	 *     (value=SINGLE_BYTE_STRING | value=DOUBLE_BYTE_STRING)
	 */
	protected void sequence_CharacterString(ISerializationContext context, CharacterString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ConfigurationDeclaration
	 *     LibraryElementDeclaration returns ConfigurationDeclaration
	 *     ConfigurationDeclaration returns ConfigurationDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier globalVarDeclarations=GlobalVarDeclarations? resdecl=ResourceDeclaration)
	 */
	protected void sequence_ConfigurationDeclaration(ISerializationContext context, ConfigurationDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataSink returns DataSink
	 *
	 * Constraint:
	 *     (globvar=GlobalVar | dirvar=DirectVariable)
	 */
	protected void sequence_DataSink(ISerializationContext context, DataSink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DataTypeDeclaration
	 *     LibraryElementDeclaration returns DataTypeDeclaration
	 *     DataTypeDeclaration returns DataTypeDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier typeDeclaration+=TypeDeclaration typeDeclaration+=TypeDeclaration*)
	 */
	protected void sequence_DataTypeDeclaration(ISerializationContext context, DataTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns DateAndTimeLiteral
	 *     Expression returns DateAndTimeLiteral
	 *     OrExpression returns DateAndTimeLiteral
	 *     OrExpression.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     XorExpression returns DateAndTimeLiteral
	 *     XorExpression.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     AndExpression returns DateAndTimeLiteral
	 *     AndExpression.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     Comparison returns DateAndTimeLiteral
	 *     Comparison.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     AddExpression returns DateAndTimeLiteral
	 *     AddExpression.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     Term returns DateAndTimeLiteral
	 *     Term.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     PowerExpression returns DateAndTimeLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns DateAndTimeLiteral
	 *     UnaryExpression returns DateAndTimeLiteral
	 *     PrimaryExpression returns DateAndTimeLiteral
	 *     ProgDataSource returns DateAndTimeLiteral
	 *     DataSource returns DateAndTimeLiteral
	 *     Constant returns DateAndTimeLiteral
	 *     TimeLiteral returns DateAndTimeLiteral
	 *     DateAndTimeLiteral returns DateAndTimeLiteral
	 *
	 * Constraint:
	 *     (
	 *         year=Integer 
	 *         month=Integer 
	 *         day=Integer 
	 *         hour=Integer 
	 *         minute=Integer 
	 *         second=Integer
	 *     )
	 */
	protected void sequence_DateAndTimeLiteral(ISerializationContext context, DateAndTimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__YEAR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__MONTH));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__DAY));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__HOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__HOUR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__MINUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__MINUTE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_AND_TIME_LITERAL__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateAndTimeLiteralAccess().getYearIntegerParserRuleCall_1_0(), semanticObject.getYear());
		feeder.accept(grammarAccess.getDateAndTimeLiteralAccess().getMonthIntegerParserRuleCall_3_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getDateAndTimeLiteralAccess().getDayIntegerParserRuleCall_5_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getDateAndTimeLiteralAccess().getHourIntegerParserRuleCall_7_0(), semanticObject.getHour());
		feeder.accept(grammarAccess.getDateAndTimeLiteralAccess().getMinuteIntegerParserRuleCall_9_0(), semanticObject.getMinute());
		feeder.accept(grammarAccess.getDateAndTimeLiteralAccess().getSecondIntegerParserRuleCall_11_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns DateLiteral
	 *     Expression returns DateLiteral
	 *     OrExpression returns DateLiteral
	 *     OrExpression.BinaryExpression_1_0 returns DateLiteral
	 *     XorExpression returns DateLiteral
	 *     XorExpression.BinaryExpression_1_0 returns DateLiteral
	 *     AndExpression returns DateLiteral
	 *     AndExpression.BinaryExpression_1_0 returns DateLiteral
	 *     Comparison returns DateLiteral
	 *     Comparison.BinaryExpression_1_0 returns DateLiteral
	 *     AddExpression returns DateLiteral
	 *     AddExpression.BinaryExpression_1_0 returns DateLiteral
	 *     Term returns DateLiteral
	 *     Term.BinaryExpression_1_0 returns DateLiteral
	 *     PowerExpression returns DateLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns DateLiteral
	 *     UnaryExpression returns DateLiteral
	 *     PrimaryExpression returns DateLiteral
	 *     ProgDataSource returns DateLiteral
	 *     DataSource returns DateLiteral
	 *     Constant returns DateLiteral
	 *     TimeLiteral returns DateLiteral
	 *     DateLiteral returns DateLiteral
	 *
	 * Constraint:
	 *     (year=Integer month=Integer day=Integer)
	 */
	protected void sequence_DateLiteral(ISerializationContext context, DateLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_LITERAL__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_LITERAL__YEAR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_LITERAL__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_LITERAL__MONTH));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DATE_LITERAL__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DATE_LITERAL__DAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateLiteralAccess().getYearIntegerParserRuleCall_1_0(), semanticObject.getYear());
		feeder.accept(grammarAccess.getDateLiteralAccess().getMonthIntegerParserRuleCall_3_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getDateLiteralAccess().getDayIntegerParserRuleCall_5_0(), semanticObject.getDay());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DateType
	 *     LibraryElement returns DateType
	 *     DataType returns DateType
	 *     NonGenericType returns DateType
	 *     ElementaryType returns DateType
	 *     DateType returns DateType
	 *
	 * Constraint:
	 *     (typeName='DATE' | typeName='TIME_OF_DAY' | typeName='TOD' | typeName='DATE_AND_TIME' | typeName='DT')
	 */
	protected void sequence_DateType(ISerializationContext context, DateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DerivedType
	 *     LibraryElement returns DerivedType
	 *     DataType returns DerivedType
	 *     NonGenericType returns DerivedType
	 *     DerivedType returns DerivedType
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_DerivedType(ISerializationContext context, DerivedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DERIVED_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DERIVED_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDerivedTypeAccess().getNameIdentifierParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableAccess returns DirectVariable
	 *     DirectVariable returns DirectVariable
	 *     ReferencedOperand returns DirectVariable
	 *     ProgDataSource returns DirectVariable
	 *     DataSource returns DirectVariable
	 *
	 * Constraint:
	 *     name=DIRECT_VARIABLE_ID
	 */
	protected void sequence_DirectVariable(ISerializationContext context, DirectVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.DIRECT_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.DIRECT_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectVariableAccess().getNameDIRECT_VARIABLE_IDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns DurationLiteral
	 *     Expression returns DurationLiteral
	 *     OrExpression returns DurationLiteral
	 *     OrExpression.BinaryExpression_1_0 returns DurationLiteral
	 *     XorExpression returns DurationLiteral
	 *     XorExpression.BinaryExpression_1_0 returns DurationLiteral
	 *     AndExpression returns DurationLiteral
	 *     AndExpression.BinaryExpression_1_0 returns DurationLiteral
	 *     Comparison returns DurationLiteral
	 *     Comparison.BinaryExpression_1_0 returns DurationLiteral
	 *     AddExpression returns DurationLiteral
	 *     AddExpression.BinaryExpression_1_0 returns DurationLiteral
	 *     Term returns DurationLiteral
	 *     Term.BinaryExpression_1_0 returns DurationLiteral
	 *     PowerExpression returns DurationLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns DurationLiteral
	 *     UnaryExpression returns DurationLiteral
	 *     PrimaryExpression returns DurationLiteral
	 *     ProgDataSource returns DurationLiteral
	 *     DataSource returns DurationLiteral
	 *     Constant returns DurationLiteral
	 *     TimeLiteral returns DurationLiteral
	 *     DurationLiteral returns DurationLiteral
	 *
	 * Constraint:
	 *     (duration=DAYS | duration=HOURS | duration=MINUTES | duration=SECONDS | duration=MILLISECONDS)
	 */
	protected void sequence_DurationLiteral(ISerializationContext context, DurationLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclSpecification returns EdgeDeclSpecification
	 *     EdgeDeclSpecification returns EdgeDeclSpecification
	 *
	 * Constraint:
	 *     (rEdge?='R_EDGE' | fEdge?='F_EDGE')
	 */
	protected void sequence_EdgeDeclSpecification(ISerializationContext context, EdgeDeclSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EdgeDeclaration returns EdgeDeclaration
	 *
	 * Constraint:
	 *     var1List=Var1List
	 */
	protected void sequence_EdgeDeclaration(ISerializationContext context, EdgeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.EDGE_DECLARATION__VAR1_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.EDGE_DECLARATION__VAR1_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEdgeDeclarationAccess().getVar1ListVar1ListParserRuleCall_0_0(), semanticObject.getVar1List());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ElementaryType
	 *     LibraryElement returns ElementaryType
	 *     DataType returns ElementaryType
	 *     NonGenericType returns ElementaryType
	 *     ElementaryType returns ElementaryType
	 *
	 * Constraint:
	 *     (typeName='WSTRING' | typeName='TIME')
	 */
	protected void sequence_ElementaryType(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIf returns ElseIf
	 *
	 * Constraint:
	 *     (expression=Expression statementList=StatementList)
	 */
	protected void sequence_ElseIf(ISerializationContext context, ElseIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.ELSE_IF__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.ELSE_IF__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.ELSE_IF__STATEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.ELSE_IF__STATEMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseIfAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getElseIfAccess().getStatementListStatementListParserRuleCall_3_0(), semanticObject.getStatementList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns EnumDeclaration
	 *     EnumDeclaration returns EnumDeclaration
	 *
	 * Constraint:
	 *     (derivedType=DerivedType enumeration=Enumeration constant=EnumeratedValue?)
	 */
	protected void sequence_EnumDeclaration(ISerializationContext context, EnumDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumeratedValue returns EnumeratedValue
	 *     InitialElement returns EnumeratedValue
	 *     ReferencedOperand returns EnumeratedValue
	 *
	 * Constraint:
	 *     (derivedType=DerivedType name=Identifier)
	 */
	protected void sequence_EnumeratedValue(ISerializationContext context, EnumeratedValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.ENUMERATED_VALUE__DERIVED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.ENUMERATED_VALUE__DERIVED_TYPE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.ENUMERATED_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.ENUMERATED_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumeratedValueAccess().getDerivedTypeDerivedTypeParserRuleCall_0_0(), semanticObject.getDerivedType());
		feeder.accept(grammarAccess.getEnumeratedValueAccess().getNameIdentifierParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (values+=EnumeratedValue values+=EnumeratedValue*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns ExpressionOperation
	 *     ExpressionOperation returns ExpressionOperation
	 *     SimpleInstruction returns ExpressionOperation
	 *
	 * Constraint:
	 *     (operator=ExpressionOperator operand=Operand? simpleInstructionList=SimpleInstructionList?)
	 */
	protected void sequence_ExpressionOperation(ISerializationContext context, ExpressionOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgConfElement returns FBTask
	 *     FBTask returns FBTask
	 *
	 * Constraint:
	 *     (fbname=FunctionBlockDeclaration task=TaskConfiguration)
	 */
	protected void sequence_FBTask(ISerializationContext context, FBTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.FB_TASK__FBNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.FB_TASK__FBNAME));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.FB_TASK__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.FB_TASK__TASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFBTaskAccess().getFbnameFunctionBlockDeclarationParserRuleCall_0_0(), semanticObject.getFbname());
		feeder.accept(grammarAccess.getFBTaskAccess().getTaskTaskConfigurationParserRuleCall_2_0(), semanticObject.getTask());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns FunctionBlockDeclaration
	 *     LibraryElementDeclaration returns FunctionBlockDeclaration
	 *     FunctionBlockDeclaration returns FunctionBlockDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier varDeclarations+=FunctionBlockVarDeclarations* body=FunctionBlockBody?)
	 */
	protected void sequence_FunctionBlockDeclaration(ISerializationContext context, FunctionBlockDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns FunctionDeclaration
	 *     LibraryElement returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier type=NonGenericType ioVarDeclarations+=IoVarDeclarations* body=FunctionBody?)
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns GenericType
	 *     LibraryElement returns GenericType
	 *     DataType returns GenericType
	 *     GenericType returns GenericType
	 *
	 * Constraint:
	 *     (
	 *         typeName='ANY' | 
	 *         typeName='ANY_DERIVED' | 
	 *         typeName='ANY_ELEMENTARY' | 
	 *         typeName='ANY_MAGNITUDE' | 
	 *         typeName='ANY_NUM' | 
	 *         typeName='ANY_REAL' | 
	 *         typeName='ANY_INT' | 
	 *         typeName='ANY_BIT' | 
	 *         typeName='ANY_STRING' | 
	 *         typeName='ANY_DATE'
	 *     )
	 */
	protected void sequence_GenericType(ISerializationContext context, GenericType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarDecl returns GlobalVarDecl
	 *
	 * Constraint:
	 *     (spec=GlobalVarSpec specInit=SpecInit?)
	 */
	protected void sequence_GlobalVarDecl(ISerializationContext context, GlobalVarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarDeclarations returns GlobalVarDeclarations
	 *
	 * Constraint:
	 *     (globalVarDecl+=GlobalVarDecl globalVarDecl+=GlobalVarDecl*)
	 */
	protected void sequence_GlobalVarDeclarations(ISerializationContext context, GlobalVarDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarSpec returns GlobalVarList
	 *     GlobalVarList returns GlobalVarList
	 *
	 * Constraint:
	 *     (variables+=GlobalVar variables+=GlobalVar*)
	 */
	protected void sequence_GlobalVarList(ISerializationContext context, GlobalVarList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVarSpec returns GlobalVarSpec
	 *
	 * Constraint:
	 *     (variable=GlobalVar? location=Location)
	 */
	protected void sequence_GlobalVarSpec(ISerializationContext context, GlobalVarSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVar returns GlobalVar
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_GlobalVar(ISerializationContext context, GlobalVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.GLOBAL_VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.GLOBAL_VAR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalVarAccess().getNameIdentifierParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     SelectionStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (ifExpression=Expression thenStatementList=StatementList elseIfs+=ElseIf* elseStatementList=StatementList?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitializedStructure returns InitializedStructure
	 *
	 * Constraint:
	 *     (derivedType=DerivedType initialization=StructureInitialization)
	 */
	protected void sequence_InitializedStructure(ISerializationContext context, InitializedStructure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.INITIALIZED_STRUCTURE__DERIVED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.INITIALIZED_STRUCTURE__DERIVED_TYPE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.INITIALIZED_STRUCTURE__INITIALIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.INITIALIZED_STRUCTURE__INITIALIZATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitializedStructureAccess().getDerivedTypeDerivedTypeParserRuleCall_0_0(), semanticObject.getDerivedType());
		feeder.accept(grammarAccess.getInitializedStructureAccess().getInitializationStructureInitializationParserRuleCall_2_0(), semanticObject.getInitialization());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputDeclaration returns InputDeclaration
	 *
	 * Constraint:
	 *     (var1List=Var1List declSpecification=DeclSpecification)
	 */
	protected void sequence_InputDeclaration(ISerializationContext context, InputDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.INPUT_DECLARATION__VAR1_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.INPUT_DECLARATION__VAR1_LIST));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.INPUT_DECLARATION__DECL_SPECIFICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.INPUT_DECLARATION__DECL_SPECIFICATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputDeclarationAccess().getVar1ListVar1ListParserRuleCall_0_0(), semanticObject.getVar1List());
		feeder.accept(grammarAccess.getInputDeclarationAccess().getDeclSpecificationDeclSpecificationParserRuleCall_2_0(), semanticObject.getDeclSpecification());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IoVarDeclarations returns InputDeclarations
	 *     InputDeclarations returns InputDeclarations
	 *     FunctionBlockVarDeclarations returns InputDeclarations
	 *     ProgramVarDeclarations returns InputDeclarations
	 *
	 * Constraint:
	 *     (declarations+=InputDeclaration declarations+=InputDeclaration*)
	 */
	protected void sequence_InputDeclarations(ISerializationContext context, InputDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IoVarDeclarations returns InputOutputDeclarations
	 *     InputOutputDeclarations returns InputOutputDeclarations
	 *     FunctionBlockVarDeclarations returns InputOutputDeclarations
	 *     ProgramVarDeclarations returns InputOutputDeclarations
	 *
	 * Constraint:
	 *     (initDecls+=VarInitDecl initDecls+=VarInitDecl*)
	 */
	protected void sequence_InputOutputDeclarations(ISerializationContext context, InputOutputDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBody returns InstructionList
	 *     InstructionList returns InstructionList
	 *     FunctionBlockBody returns InstructionList
	 *
	 * Constraint:
	 *     (instructions+=Instruction instructions+=Instruction*)
	 */
	protected void sequence_InstructionList(ISerializationContext context, InstructionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Instruction
	 *
	 * Constraint:
	 *     (label=Label? instruction=Operation)
	 */
	protected void sequence_Instruction(ISerializationContext context, Instruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns IntegerLiteral
	 *     Expression returns IntegerLiteral
	 *     OrExpression returns IntegerLiteral
	 *     OrExpression.BinaryExpression_1_0 returns IntegerLiteral
	 *     XorExpression returns IntegerLiteral
	 *     XorExpression.BinaryExpression_1_0 returns IntegerLiteral
	 *     AndExpression returns IntegerLiteral
	 *     AndExpression.BinaryExpression_1_0 returns IntegerLiteral
	 *     Comparison returns IntegerLiteral
	 *     Comparison.BinaryExpression_1_0 returns IntegerLiteral
	 *     AddExpression returns IntegerLiteral
	 *     AddExpression.BinaryExpression_1_0 returns IntegerLiteral
	 *     Term returns IntegerLiteral
	 *     Term.BinaryExpression_1_0 returns IntegerLiteral
	 *     PowerExpression returns IntegerLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns IntegerLiteral
	 *     UnaryExpression returns IntegerLiteral
	 *     PrimaryExpression returns IntegerLiteral
	 *     ProgDataSource returns IntegerLiteral
	 *     DataSource returns IntegerLiteral
	 *     Constant returns IntegerLiteral
	 *     NumericLiteral returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     (type=IntegerType? value=IntegerValue)
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns JmpOperation
	 *     JmpOperation returns JmpOperation
	 *
	 * Constraint:
	 *     (operator=JmpOperator label=[Label|Identifier])
	 */
	protected void sequence_JmpOperation(ISerializationContext context, JmpOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.JMP_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.JMP_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.JMP_OPERATION__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.JMP_OPERATION__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJmpOperationAccess().getOperatorJmpOperatorParserRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getJmpOperationAccess().getLabelLabelIdentifierParserRuleCall_1_0_1(), semanticObject.eGet(IecPackage.Literals.JMP_OPERATION__LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Label returns Label
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.LABEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getNameIdentifierParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocatedVarDeclaration returns LocatedVarDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier? location=Location specInit=SpecInit)
	 */
	protected void sequence_LocatedVarDeclaration(ISerializationContext context, LocatedVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramVarDeclarations returns LocatedVarDeclarations
	 *     LocatedVarDeclarations returns LocatedVarDeclarations
	 *
	 * Constraint:
	 *     (locatedVarDeclaration+=LocatedVarDeclaration locatedVarDeclaration+=LocatedVarDeclaration*)
	 */
	protected void sequence_LocatedVarDeclarations(ISerializationContext context, LocatedVarDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns Location
	 *
	 * Constraint:
	 *     directVariable=DirectVariable
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.LOCATION__DIRECT_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.LOCATION__DIRECT_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationAccess().getDirectVariableDirectVariableParserRuleCall_1_0(), semanticObject.getDirectVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     modelElement+=ModelElement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableAccess returns NamedVariableAccess
	 *     SymbolicVariableAccess returns NamedVariableAccess
	 *     NamedVariableAccess returns NamedVariableAccess
	 *     ReferencedOperand returns NamedVariableAccess
	 *
	 * Constraint:
	 *     namedVariable=[Variable|Identifier]
	 */
	protected void sequence_NamedVariableAccess(ISerializationContext context, NamedVariableAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.NAMED_VARIABLE_ACCESS__NAMED_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.NAMED_VARIABLE_ACCESS__NAMED_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedVariableAccessAccess().getNamedVariableVariableIdentifierParserRuleCall_0_1(), semanticObject.eGet(IecPackage.Literals.NAMED_VARIABLE_ACCESS__NAMED_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Operand
	 *
	 * Constraint:
	 *     (constant=Constant | reference=ReferencedOperand)
	 */
	protected void sequence_Operand(ISerializationContext context, Operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IoVarDeclarations returns OutputDeclarations
	 *     OutputDeclarations returns OutputDeclarations
	 *     FunctionBlockVarDeclarations returns OutputDeclarations
	 *     ProgramVarDeclarations returns OutputDeclarations
	 *
	 * Constraint:
	 *     (initDecls+=VarInitDecl initDecls+=VarInitDecl*)
	 */
	protected void sequence_OutputDeclarations(ISerializationContext context, OutputDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamAssignment returns ParamAssignment
	 *
	 * Constraint:
	 *     (
	 *         (variablename=[NamedVariableAccess|Identifier]? expression=Expression) | 
	 *         (not?='NOT'? variable1=[NamedVariableAccess|Identifier] variable2=[Variable|Identifier])
	 *     )
	 */
	protected void sequence_ParamAssignment(ISerializationContext context, ParamAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParenthesesExpression returns Expression
	 *
	 * Constraint:
	 *     (openbr='(' expression=Expression closebr=')')
	 */
	protected void sequence_ParenthesesExpression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.EXPRESSION__OPENBR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.EXPRESSION__OPENBR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.EXPRESSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.EXPRESSION__CLOSEBR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.EXPRESSION__CLOSEBR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesesExpressionAccess().getOpenbrLeftParenthesisKeyword_0_0(), semanticObject.getOpenbr());
		feeder.accept(grammarAccess.getParenthesesExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getParenthesesExpressionAccess().getClosebrRightParenthesisKeyword_2_0(), semanticObject.getClosebr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     OrExpression returns Expression
	 *     OrExpression.BinaryExpression_1_0 returns Expression
	 *     XorExpression returns Expression
	 *     XorExpression.BinaryExpression_1_0 returns Expression
	 *     AndExpression returns Expression
	 *     AndExpression.BinaryExpression_1_0 returns Expression
	 *     Comparison returns Expression
	 *     Comparison.BinaryExpression_1_0 returns Expression
	 *     AddExpression returns Expression
	 *     AddExpression.BinaryExpression_1_0 returns Expression
	 *     Term returns Expression
	 *     Term.BinaryExpression_1_0 returns Expression
	 *     PowerExpression returns Expression
	 *     PowerExpression.BinaryExpression_1_0 returns Expression
	 *     UnaryExpression returns Expression
	 *     PrimaryExpression returns Expression
	 *
	 * Constraint:
	 *     (
	 *         variable=VariableAccess | 
	 *         (fbname=[FunctionDeclaration|Identifier] openbr='(' paramassignment+=ParamAssignment paramassignment+=ParamAssignment* closebr=')') | 
	 *         (openbr='(' expression=Expression closebr=')')
	 *     )
	 */
	protected void sequence_ParenthesesExpression_PrimaryExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlainIntegerType returns SignedIntegerType
	 *
	 * Constraint:
	 *     {SignedIntegerType}
	 */
	protected void sequence_PlainIntegerType(ISerializationContext context, SignedIntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns SignedIntegerType
	 *     LibraryElement returns SignedIntegerType
	 *     DataType returns SignedIntegerType
	 *     NonGenericType returns SignedIntegerType
	 *     ElementaryType returns SignedIntegerType
	 *     NumericType returns SignedIntegerType
	 *     IntegerType returns SignedIntegerType
	 *
	 * Constraint:
	 *     (typeName='SINT' | typeName='DINT' | typeName='LINT')?
	 */
	protected void sequence_PlainIntegerType_SignedIntegerType(ISerializationContext context, SignedIntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PowerExpression returns BinaryExpression
	 *     PowerExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 */
	protected void sequence_PowerExpression(ISerializationContext context, BinaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.BINARY_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.BINARY_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.BINARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.BINARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.BINARY_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.BINARY_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerExpressionAccess().getBinaryExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowerExpressionAccess().getOperatorAsteriskAsteriskKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPowerExpressionAccess().getRightUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BinaryExpression
	 *     Term.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=Term_BinaryExpression_1_0 (operator='*' | operator='/' | operator='MOD') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 operator='**' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_PowerExpression_Term(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgConfElement returns ProgCNXN
	 *     ProgCNXN returns ProgCNXN
	 *
	 * Constraint:
	 *     ((variablename=Identifier progd=ProgDataSource) | progd=DataSink)
	 */
	protected void sequence_ProgCNXN(ISerializationContext context, ProgCNXN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgConfElements returns ProgConfElements
	 *
	 * Constraint:
	 *     (progconf+=ProgConfElement progconf+=ProgConfElement*)
	 */
	protected void sequence_ProgConfElements(ISerializationContext context, ProgConfElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramAccessDecl returns ProgramAccessDecl
	 *
	 * Constraint:
	 *     (accessName=Variable symbolicVariable=NamedVariableAccess typeName=NonGenericType direction=Direction?)
	 */
	protected void sequence_ProgramAccessDecl(ISerializationContext context, ProgramAccessDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramVarDeclarations returns ProgramAccessDecls
	 *     ProgramAccessDecls returns ProgramAccessDecls
	 *
	 * Constraint:
	 *     (programAccessDecl+=ProgramAccessDecl programAccessDecl+=ProgramAccessDecl*)
	 */
	protected void sequence_ProgramAccessDecls(ISerializationContext context, ProgramAccessDecls semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramConfiguration returns ProgramConfiguration
	 *
	 * Constraint:
	 *     (name=Identifier task=[TaskConfiguration|Identifier]? prog=[ProgramDeclaration|Identifier] progConf=ProgConfElements?)
	 */
	protected void sequence_ProgramConfiguration(ISerializationContext context, ProgramConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ProgramDeclaration
	 *     LibraryElementDeclaration returns ProgramDeclaration
	 *     ProgramDeclaration returns ProgramDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier varDeclarations+=ProgramVarDeclarations* body=FunctionBlockBody?)
	 */
	protected void sequence_ProgramDeclaration(ISerializationContext context, ProgramDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns RangeDeclaration
	 *     RangeDeclaration returns RangeDeclaration
	 *
	 * Constraint:
	 *     (derivedType=DerivedType baseType=ElementaryType range=SubRangeWithSign constant=SignedInteger?)
	 */
	protected void sequence_RangeDeclaration(ISerializationContext context, RangeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns RealLiteral
	 *     Expression returns RealLiteral
	 *     OrExpression returns RealLiteral
	 *     OrExpression.BinaryExpression_1_0 returns RealLiteral
	 *     XorExpression returns RealLiteral
	 *     XorExpression.BinaryExpression_1_0 returns RealLiteral
	 *     AndExpression returns RealLiteral
	 *     AndExpression.BinaryExpression_1_0 returns RealLiteral
	 *     Comparison returns RealLiteral
	 *     Comparison.BinaryExpression_1_0 returns RealLiteral
	 *     AddExpression returns RealLiteral
	 *     AddExpression.BinaryExpression_1_0 returns RealLiteral
	 *     Term returns RealLiteral
	 *     Term.BinaryExpression_1_0 returns RealLiteral
	 *     PowerExpression returns RealLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns RealLiteral
	 *     UnaryExpression returns RealLiteral
	 *     PrimaryExpression returns RealLiteral
	 *     ProgDataSource returns RealLiteral
	 *     DataSource returns RealLiteral
	 *     Constant returns RealLiteral
	 *     NumericLiteral returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     (type=RealType? value=RealValue)
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns RealType
	 *     LibraryElement returns RealType
	 *     DataType returns RealType
	 *     NonGenericType returns RealType
	 *     ElementaryType returns RealType
	 *     NumericType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     (typeName='REAL' | typeName='LREAL')
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ResourceDeclaration
	 *     LibraryElementDeclaration returns ResourceDeclaration
	 *     ResourceDeclaration returns ResourceDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier resname=Identifier globalVarDeclarations=GlobalVarDeclarations? singleresource=SingleResourceDeclaration)
	 */
	protected void sequence_ResourceDeclaration(ISerializationContext context, ResourceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignedIntegerType returns SignedIntegerType
	 *
	 * Constraint:
	 *     (typeName='SINT' | typeName='DINT' | typeName='LINT')
	 */
	protected void sequence_SignedIntegerType(ISerializationContext context, SignedIntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleInstructionList returns SimpleInstructionList
	 *
	 * Constraint:
	 *     (instructions+=SimpleInstruction instructions+=SimpleInstruction*)
	 */
	protected void sequence_SimpleInstructionList(ISerializationContext context, SimpleInstructionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns SimpleOperation
	 *     SimpleOperation returns SimpleOperation
	 *     SimpleInstruction returns SimpleOperation
	 *
	 * Constraint:
	 *     (operator=SimpleOperator operand=Operand?)
	 */
	protected void sequence_SimpleOperation(ISerializationContext context, SimpleOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns SimpleTypeDeclaration
	 *     SimpleTypeDeclaration returns SimpleTypeDeclaration
	 *
	 * Constraint:
	 *     (derivedType=DerivedType specInit=SpecInit)
	 */
	protected void sequence_SimpleTypeDeclaration(ISerializationContext context, SimpleTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.TYPE_DECLARATION__DERIVED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.TYPE_DECLARATION__DERIVED_TYPE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.SIMPLE_TYPE_DECLARATION__SPEC_INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.SIMPLE_TYPE_DECLARATION__SPEC_INIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeDeclarationAccess().getDerivedTypeDerivedTypeParserRuleCall_0_0(), semanticObject.getDerivedType());
		feeder.accept(grammarAccess.getSimpleTypeDeclarationAccess().getSpecInitSpecInitParserRuleCall_2_0(), semanticObject.getSpecInit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SingleResourceDeclaration returns SingleResourceDeclaration
	 *
	 * Constraint:
	 *     (taskConf=TaskConfiguration? programConf+=ProgramConfiguration programConf+=ProgramConfiguration?)
	 */
	protected void sequence_SingleResourceDeclaration(ISerializationContext context, SingleResourceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpecInit returns SpecInit
	 *
	 * Constraint:
	 *     ((baseType=ElementaryType | baseType=DerivedType) (constant=Constant | constant=EnumeratedValue | constant=ArrayInitialization)?)
	 */
	protected void sequence_SpecInit(ISerializationContext context, SpecInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBody returns StatementList
	 *     StatementList returns StatementList
	 *     FunctionBlockBody returns StatementList
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns StringDeclaration
	 *     StringDeclaration returns StringDeclaration
	 *
	 * Constraint:
	 *     (derivedType=DerivedType string?='STRING'? size=Integer initialValue=CharacterString?)
	 */
	protected void sequence_StringDeclaration(ISerializationContext context, StringDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns StringType
	 *     LibraryElement returns StringType
	 *     DataType returns StringType
	 *     NonGenericType returns StringType
	 *     ElementaryType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructureDeclaration returns StructureDeclaration
	 *
	 * Constraint:
	 *     (structureElement+=StructureElementDeclaration structureElement+=StructureElementDeclaration*)
	 */
	protected void sequence_StructureDeclaration(ISerializationContext context, StructureDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructureElementDeclaration returns StructureElementDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier specInit=SpecInit)
	 */
	protected void sequence_StructureElementDeclaration(ISerializationContext context, StructureElementDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_DECLARATION__SPEC_INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_DECLARATION__SPEC_INIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStructureElementDeclarationAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStructureElementDeclarationAccess().getSpecInitSpecInitParserRuleCall_2_0(), semanticObject.getSpecInit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StructureElementInitialization returns StructureElementInitialization
	 *
	 * Constraint:
	 *     (name=Identifier value=InitialElement)
	 */
	protected void sequence_StructureElementInitialization(ISerializationContext context, StructureElementInitialization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_INITIALIZATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_INITIALIZATION__NAME));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_INITIALIZATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.STRUCTURE_ELEMENT_INITIALIZATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStructureElementInitializationAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStructureElementInitializationAccess().getValueInitialElementParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns StructureInitialization
	 *     StructureInitialization returns StructureInitialization
	 *
	 * Constraint:
	 *     (initialElements+=StructureElementInitialization initialElements+=StructureElementInitialization*)
	 */
	protected void sequence_StructureInitialization(ISerializationContext context, StructureInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns StructureTypeDeclaration
	 *     StructureTypeDeclaration returns StructureTypeDeclaration
	 *
	 * Constraint:
	 *     (derivedType=DerivedType (declaration=StructureDeclaration | initialization=InitializedStructure))
	 */
	protected void sequence_StructureTypeDeclaration(ISerializationContext context, StructureTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableAccess returns StructuredVariable
	 *     SymbolicVariableAccess returns StructuredVariable
	 *     MultiElementVariable returns StructuredVariable
	 *     StructuredVariable returns StructuredVariable
	 *     ReferencedOperand returns StructuredVariable
	 *
	 * Constraint:
	 *     (recordVariable=[Variable|Identifier] fieldSelector=FIELD_SELECTOR)
	 */
	protected void sequence_StructuredVariable(ISerializationContext context, StructuredVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.STRUCTURED_VARIABLE__RECORD_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.STRUCTURED_VARIABLE__RECORD_VARIABLE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.STRUCTURED_VARIABLE__FIELD_SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.STRUCTURED_VARIABLE__FIELD_SELECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStructuredVariableAccess().getRecordVariableVariableIdentifierParserRuleCall_0_0_1(), semanticObject.eGet(IecPackage.Literals.STRUCTURED_VARIABLE__RECORD_VARIABLE, false));
		feeder.accept(grammarAccess.getStructuredVariableAccess().getFieldSelectorFIELD_SELECTORTerminalRuleCall_1_0(), semanticObject.getFieldSelector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskConfiguration returns TaskConfiguration
	 *
	 * Constraint:
	 *     (name=Identifier taskInit=TaskInitialization)
	 */
	protected void sequence_TaskConfiguration(ISerializationContext context, TaskConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.TASK_CONFIGURATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.TASK_CONFIGURATION__NAME));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.TASK_CONFIGURATION__TASK_INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.TASK_CONFIGURATION__TASK_INIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskConfigurationAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTaskConfigurationAccess().getTaskInitTaskInitializationParserRuleCall_2_0(), semanticObject.getTaskInit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TaskInitialization returns TaskInitialization
	 *
	 * Constraint:
	 *     (single=DataSource? interval=DataSource? prior=INT)
	 */
	protected void sequence_TaskInitialization(ISerializationContext context, TaskInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialElement returns TimeOfDayLiteral
	 *     Expression returns TimeOfDayLiteral
	 *     OrExpression returns TimeOfDayLiteral
	 *     OrExpression.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     XorExpression returns TimeOfDayLiteral
	 *     XorExpression.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     AndExpression returns TimeOfDayLiteral
	 *     AndExpression.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     Comparison returns TimeOfDayLiteral
	 *     Comparison.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     AddExpression returns TimeOfDayLiteral
	 *     AddExpression.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     Term returns TimeOfDayLiteral
	 *     Term.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     PowerExpression returns TimeOfDayLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns TimeOfDayLiteral
	 *     UnaryExpression returns TimeOfDayLiteral
	 *     PrimaryExpression returns TimeOfDayLiteral
	 *     ProgDataSource returns TimeOfDayLiteral
	 *     DataSource returns TimeOfDayLiteral
	 *     Constant returns TimeOfDayLiteral
	 *     TimeLiteral returns TimeOfDayLiteral
	 *     TimeOfDayLiteral returns TimeOfDayLiteral
	 *
	 * Constraint:
	 *     (hour=Integer minute=Integer second=Integer)
	 */
	protected void sequence_TimeOfDayLiteral(ISerializationContext context, TimeOfDayLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.TIME_OF_DAY_LITERAL__HOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.TIME_OF_DAY_LITERAL__HOUR));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.TIME_OF_DAY_LITERAL__MINUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.TIME_OF_DAY_LITERAL__MINUTE));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.TIME_OF_DAY_LITERAL__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.TIME_OF_DAY_LITERAL__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeOfDayLiteralAccess().getHourIntegerParserRuleCall_1_0(), semanticObject.getHour());
		feeder.accept(grammarAccess.getTimeOfDayLiteralAccess().getMinuteIntegerParserRuleCall_3_0(), semanticObject.getMinute());
		feeder.accept(grammarAccess.getTimeOfDayLiteralAccess().getSecondIntegerParserRuleCall_5_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     OrExpression returns UnaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     XorExpression returns UnaryExpression
	 *     XorExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     Comparison returns UnaryExpression
	 *     Comparison.BinaryExpression_1_0 returns UnaryExpression
	 *     AddExpression returns UnaryExpression
	 *     AddExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     Term returns UnaryExpression
	 *     Term.BinaryExpression_1_0 returns UnaryExpression
	 *     PowerExpression returns UnaryExpression
	 *     PowerExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     ((operator='NOT' | operator='-') expression=UnaryExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns UnsignedIntegerType
	 *     LibraryElement returns UnsignedIntegerType
	 *     DataType returns UnsignedIntegerType
	 *     NonGenericType returns UnsignedIntegerType
	 *     ElementaryType returns UnsignedIntegerType
	 *     NumericType returns UnsignedIntegerType
	 *     IntegerType returns UnsignedIntegerType
	 *     UnsignedIntegerType returns UnsignedIntegerType
	 *
	 * Constraint:
	 *     (typeName='USINT' | typeName='UINT' | typeName='UDINT' | typeName='ULINT')
	 */
	protected void sequence_UnsignedIntegerType(ISerializationContext context, UnsignedIntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var1List returns Var1List
	 *
	 * Constraint:
	 *     (variables+=Variable variables+=Variable*)
	 */
	protected void sequence_Var1List(ISerializationContext context, Var1List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclSpecification returns VarDeclSpecification
	 *     VarDeclSpecification returns VarDeclSpecification
	 *
	 * Constraint:
	 *     specInit=SpecInit
	 */
	protected void sequence_VarDeclSpecification(ISerializationContext context, VarDeclSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.VAR_DECL_SPECIFICATION__SPEC_INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.VAR_DECL_SPECIFICATION__SPEC_INIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclSpecificationAccess().getSpecInitSpecInitParserRuleCall_0(), semanticObject.getSpecInit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBlockVarDeclarations returns VarDeclarations
	 *     OtherVarDeclarations returns VarDeclarations
	 *     VarDeclarations returns VarDeclarations
	 *     ProgramVarDeclarations returns VarDeclarations
	 *
	 * Constraint:
	 *     (constant?='CONSTANT'? initDecls+=VarInitDecl initDecls+=VarInitDecl*)
	 */
	protected void sequence_VarDeclarations(ISerializationContext context, VarDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarInitDecl returns VarInitDecl
	 *
	 * Constraint:
	 *     (var1List=Var1List specInit=SpecInit)
	 */
	protected void sequence_VarInitDecl(ISerializationContext context, VarInitDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.VAR_INIT_DECL__VAR1_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.VAR_INIT_DECL__VAR1_LIST));
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.VAR_INIT_DECL__SPEC_INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.VAR_INIT_DECL__SPEC_INIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarInitDeclAccess().getVar1ListVar1ListParserRuleCall_0_0(), semanticObject.getVar1List());
		feeder.accept(grammarAccess.getVarInitDeclAccess().getSpecInitSpecInitParserRuleCall_2_0(), semanticObject.getSpecInit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IecPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IecPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIdentifierParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
